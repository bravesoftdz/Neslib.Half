unit Neslib.Half;
{< Half-Precision Floating-Point library.

   Defines the Half type, which is a 16-bit floating-point value:

     https://en.wikipedia.org/wiki/Half-precision_floating-point_format

   The Half type uses overloaded operators so you can use it just like a Single
   or Double type (albeit with lower precision).

   This unit also defines a record helper for the Half type to provide access to
   the internals of the Half type (in a similar way that there are record
   helpers for the Single and Double types).

   The Half type is used by some image formats to provide a higher dynamic range
   than 8 bits per channel, without resorting to the overhead of using 32 bits
   per channel. You can also use it for more efficient storage of floating-point
   values in case the value can be fit into a Half without loss of precision.
   You can use GetSmallestFloatType to determine if a Double value fits into a
   Single or Half without loss of precision.

   This library uses fast conversion algorithms developed by Jeroen van der Zijp
   to convert from Half to Single and vice versa in a fast but accurate way (see
   his paper "Fast Half Float Conversions",
   ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf) }

{$SCOPEDENUMS ON}
{$EXCESSPRECISION OFF}

interface

uses
  System.SysUtils;

type
  { Half-precision floating-point value }
  Half = packed record
  {$REGION 'Internal Declarations'}
  private
    FData: UInt16;
  private
    class function Int32ToHalf(AValue: Int32): UInt16; static;
    class function UInt32ToHalf(AValue: UInt32): UInt16; static;
    class function Int64ToHalf(AValue: Int64): UInt16; static;
    class function UInt64ToHalf(AValue: UInt64): UInt16; static;
    class function TruncInt64(const AValue: Half): Int64; static;
  {$ENDREGION 'Internal Declarations'}
  public
    { Implicit conversion to Half }
    class operator Implicit(const AValue: Int8): Half; inline; static;
    class operator Implicit(const AValue: UInt8): Half; inline; static;
    class operator Implicit(const AValue: Int16): Half; inline; static;
    class operator Implicit(const AValue: UInt16): Half; inline; static;
    class operator Implicit(const AValue: Int32): Half; inline; static;
    class operator Implicit(const AValue: UInt32): Half; inline; static;
    class operator Implicit(const AValue: Int64): Half; inline; static;
    class operator Implicit(const AValue: UInt64): Half; inline; static;
    class operator Implicit(const AValue: Single): Half; static;
    class operator Implicit(const AValue: Double): Half; static;

    { Implicit conversion from Half }
    class operator Implicit(const AValue: Half): Single; static;
    class operator Implicit(const AValue: Half): Double; inline; static;

    { Explicit convertion from Half }
    class operator Explicit(const AValue: Half): Int8; inline; static;
    class operator Explicit(const AValue: Half): UInt8; inline; static;
    class operator Explicit(const AValue: Half): Int16; inline; static;
    class operator Explicit(const AValue: Half): UInt16; inline; static;
    class operator Explicit(const AValue: Half): Int32; inline; static;
    class operator Explicit(const AValue: Half): UInt32; inline; static;
    class operator Explicit(const AValue: Half): Int64; inline; static;
    class operator Explicit(const AValue: Half): UInt64; inline; static;

    { Truncate & Round (conversion from Half to Integer) }
    class operator Trunc(const AValue: Half): Integer; static;
    class operator Round(const AValue: Half): Integer; static;

    { Equality }
    class operator Equal(const ALeft, ARight: Half): Boolean; static;
    class operator NotEqual(const ALeft, ARight: Half): Boolean; inline; static;
    class operator GreaterThan(const ALeft, ARight: Half): Boolean; static;
    class operator GreaterThanOrEqual(const ALeft, ARight: Half): Boolean; static;
    class operator LessThan(const ALeft, ARight: Half): Boolean; static;
    class operator LessThanOrEqual(const ALeft, ARight: Half): Boolean; static;

    { Arithmetic }
    class operator Negative(const AValue: Half): Half; static;
    class operator Positive(const AValue: Half): Half; static;
    class operator Add(const ALeft, ARight: Half): Half; static;
    class operator Subtract(const ALeft, ARight: Half): Half; static;
    class operator Multiply(const ALeft, ARight: Half): Half; static;
    class operator Divide(const ALeft, ARight: Half): Half; static;
  end;

type
  { Record helper that provides access to the internals of the Half type. }
  THalfHelper = record helper for Half
  {$REGION 'Internal Declarations'}
  private
    function GetBytes(const AIndex: Integer): Byte;
    function GetExp: Cardinal; inline;
    function GetFrac: Cardinal; inline;
    function GetSign: Boolean; inline;
    function GetWords(const AIndex: Integer): Word;
    procedure SetBytes(const AIndex: Integer; const AValue: Byte);
    procedure SetExp(const AValue: Cardinal);
    procedure SetFrac(const AValue: Cardinal);
    procedure SetSign(const AValue: Boolean);
    procedure SetWords(const AIndex: Integer; const AValue: Word);
  {$ENDREGION 'Internal Declarations'}
  public const
    Epsilon         : Half = (FData: $1400);
    MaxValue        : Half = (FData: $7BFF);
    MinValue        : Half = (FData: $0400);
    PositiveInfinity: Half = (FData: $7C00);
    NegativeInfinity: Half = (FData: $FC00);
    NaN             : Half = (FData: $7FFF);
  public
    function Exponent: Integer;
    function Fraction: Extended;
    function Mantissa: Cardinal;

    property Sign: Boolean read GetSign write SetSign;
    property Exp: Cardinal read GetExp write SetExp;
    property Frac: Cardinal read GetFrac write SetFrac;

    function SpecialType: TFloatSpecial;
    procedure BuildUp(const ASignFlag: Boolean; const AMantissa: Cardinal;
      const AExponent: Integer);
    function IsNan: Boolean; overload; inline;
    function IsInfinity: Boolean; overload; inline;
    function IsNegativeInfinity: Boolean; overload; inline;
    function IsPositiveInfinity: Boolean; overload; inline;

    property Bytes[const AIndex: Integer]: Byte read GetBytes write SetBytes; // 0..1
    property Words[const AIndex: Integer]: Word read GetWords write SetWords; // 0..0

    class function IsNan(const AValue: Half): Boolean; overload; inline; static;
    class function IsInfinity(const AValue: Half): Boolean; overload; inline; static;
    class function IsNegativeInfinity(const AValue: Half): Boolean; overload; inline; static;
    class function IsPositiveInfinity(const AValue: Half): Boolean; overload; inline; static;
    class function Size: Integer; inline; static;
  end;

type
  { Types of floating-point values. }
  TFloatType = (Half, Single, Double);

{ Determine that smallest floating-point type that fits a Double value without
  loss of precision.

  Parameters:
    AValue: the Double value to check.

  Returns:
    The smalles floating-point type. }
function GetSmallestFloatType(const AValue: Double): TFloatType;

implementation

uses
  System.SysConst;

{ Half-precision floating-point format (see also
  https://en.wikipedia.org/wiki/Half-precision_floating-point_format):

       5 bits    10 bits
    +-+---------+-------------------+
    |S|E|E|E|E|E|M|M|M|M|M|M|M|M|M|M|
    +-+---------+-------------------+
       $7C00     $03FF
     $8000

  Exponent bias: 15
  Exponent range: -14 to 15

  Exponent       Mantissa=0    Mantissa<>0    Value
  --------------------------------------------------------------------------
  00000          0, -0         subnormals     Sign * 2^-14 * 0.mmmmmmmmmm
  00001-11110        normalized value         Sign * 2^(e-15) * 1.mmmmmmmmmm
  11111          +/-inf        NaN
  --------------------------------------------------------------------------

  **************************************************************************

  In contrast to Single-precision floating-point:

       8 bits          23 bits
    +-+---------------+---------------------------------------------+
    |S|E|E|E|E|E|E|E|E|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|
    +-+---------------+---------------------------------------------+
       $7F800000       $007FFFFF
     $80000000

  Exponent bias: 127
  Exponent range: -126 to 127

  Exponent       Mantissa=0    Mantissa<>0    Value
  --------------------------------------------------------------------------
  $00            0, -0         subnormals     Sign * 2^-126 * 0.mmmmm...
  $01-$FE            normalized value         Sign * 2^(e-127) * 1.mmmmm...
  $FF            +/-inf        NaN
  --------------------------------------------------------------------------

  **************************************************************************

  And Double-precision floating-point:

       11 bits               52 bits
    +-+---------------------+---------------------------------------------...
    |S|E|E|E|E|E|E|E|E|E|E|E|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M|M...
    +-+---------------------+---------------------------------------------...
       $7FF0000000000000     $000FFFFFFFFFFFFF
     $8000000000000000

  Exponent bias: 1023
  Exponent range: -1022 to 1023

  Exponent       Mantissa=0    Mantissa<>0    Value
  --------------------------------------------------------------------------
  $0000          0, -0         subnormals     Sign * 2^-1022 * 0.mmmmm...
  $0001-$07FE        normalized value         Sign * 2^(e-1023) * 1.mmmmm...
  $07FF            +/-inf        NaN
  -------------------------------------------------------------------------- }

const
  MANTISSA_TABLE: array [0..2047] of UInt32 = (
    $00000000, $33800000, $34000000, $34400000, $34800000, $34A00000, $34C00000, $34E00000,
    $35000000, $35100000, $35200000, $35300000, $35400000, $35500000, $35600000, $35700000,
    $35800000, $35880000, $35900000, $35980000, $35A00000, $35A80000, $35B00000, $35B80000,
    $35C00000, $35C80000, $35D00000, $35D80000, $35E00000, $35E80000, $35F00000, $35F80000,
    $36000000, $36040000, $36080000, $360C0000, $36100000, $36140000, $36180000, $361C0000,
    $36200000, $36240000, $36280000, $362C0000, $36300000, $36340000, $36380000, $363C0000,
    $36400000, $36440000, $36480000, $364C0000, $36500000, $36540000, $36580000, $365C0000,
    $36600000, $36640000, $36680000, $366C0000, $36700000, $36740000, $36780000, $367C0000,
    $36800000, $36820000, $36840000, $36860000, $36880000, $368A0000, $368C0000, $368E0000,
    $36900000, $36920000, $36940000, $36960000, $36980000, $369A0000, $369C0000, $369E0000,
    $36A00000, $36A20000, $36A40000, $36A60000, $36A80000, $36AA0000, $36AC0000, $36AE0000,
    $36B00000, $36B20000, $36B40000, $36B60000, $36B80000, $36BA0000, $36BC0000, $36BE0000,
    $36C00000, $36C20000, $36C40000, $36C60000, $36C80000, $36CA0000, $36CC0000, $36CE0000,
    $36D00000, $36D20000, $36D40000, $36D60000, $36D80000, $36DA0000, $36DC0000, $36DE0000,
    $36E00000, $36E20000, $36E40000, $36E60000, $36E80000, $36EA0000, $36EC0000, $36EE0000,
    $36F00000, $36F20000, $36F40000, $36F60000, $36F80000, $36FA0000, $36FC0000, $36FE0000,
    $37000000, $37010000, $37020000, $37030000, $37040000, $37050000, $37060000, $37070000,
    $37080000, $37090000, $370A0000, $370B0000, $370C0000, $370D0000, $370E0000, $370F0000,
    $37100000, $37110000, $37120000, $37130000, $37140000, $37150000, $37160000, $37170000,
    $37180000, $37190000, $371A0000, $371B0000, $371C0000, $371D0000, $371E0000, $371F0000,
    $37200000, $37210000, $37220000, $37230000, $37240000, $37250000, $37260000, $37270000,
    $37280000, $37290000, $372A0000, $372B0000, $372C0000, $372D0000, $372E0000, $372F0000,
    $37300000, $37310000, $37320000, $37330000, $37340000, $37350000, $37360000, $37370000,
    $37380000, $37390000, $373A0000, $373B0000, $373C0000, $373D0000, $373E0000, $373F0000,
    $37400000, $37410000, $37420000, $37430000, $37440000, $37450000, $37460000, $37470000,
    $37480000, $37490000, $374A0000, $374B0000, $374C0000, $374D0000, $374E0000, $374F0000,
    $37500000, $37510000, $37520000, $37530000, $37540000, $37550000, $37560000, $37570000,
    $37580000, $37590000, $375A0000, $375B0000, $375C0000, $375D0000, $375E0000, $375F0000,
    $37600000, $37610000, $37620000, $37630000, $37640000, $37650000, $37660000, $37670000,
    $37680000, $37690000, $376A0000, $376B0000, $376C0000, $376D0000, $376E0000, $376F0000,
    $37700000, $37710000, $37720000, $37730000, $37740000, $37750000, $37760000, $37770000,
    $37780000, $37790000, $377A0000, $377B0000, $377C0000, $377D0000, $377E0000, $377F0000,
    $37800000, $37808000, $37810000, $37818000, $37820000, $37828000, $37830000, $37838000,
    $37840000, $37848000, $37850000, $37858000, $37860000, $37868000, $37870000, $37878000,
    $37880000, $37888000, $37890000, $37898000, $378A0000, $378A8000, $378B0000, $378B8000,
    $378C0000, $378C8000, $378D0000, $378D8000, $378E0000, $378E8000, $378F0000, $378F8000,
    $37900000, $37908000, $37910000, $37918000, $37920000, $37928000, $37930000, $37938000,
    $37940000, $37948000, $37950000, $37958000, $37960000, $37968000, $37970000, $37978000,
    $37980000, $37988000, $37990000, $37998000, $379A0000, $379A8000, $379B0000, $379B8000,
    $379C0000, $379C8000, $379D0000, $379D8000, $379E0000, $379E8000, $379F0000, $379F8000,
    $37A00000, $37A08000, $37A10000, $37A18000, $37A20000, $37A28000, $37A30000, $37A38000,
    $37A40000, $37A48000, $37A50000, $37A58000, $37A60000, $37A68000, $37A70000, $37A78000,
    $37A80000, $37A88000, $37A90000, $37A98000, $37AA0000, $37AA8000, $37AB0000, $37AB8000,
    $37AC0000, $37AC8000, $37AD0000, $37AD8000, $37AE0000, $37AE8000, $37AF0000, $37AF8000,
    $37B00000, $37B08000, $37B10000, $37B18000, $37B20000, $37B28000, $37B30000, $37B38000,
    $37B40000, $37B48000, $37B50000, $37B58000, $37B60000, $37B68000, $37B70000, $37B78000,
    $37B80000, $37B88000, $37B90000, $37B98000, $37BA0000, $37BA8000, $37BB0000, $37BB8000,
    $37BC0000, $37BC8000, $37BD0000, $37BD8000, $37BE0000, $37BE8000, $37BF0000, $37BF8000,
    $37C00000, $37C08000, $37C10000, $37C18000, $37C20000, $37C28000, $37C30000, $37C38000,
    $37C40000, $37C48000, $37C50000, $37C58000, $37C60000, $37C68000, $37C70000, $37C78000,
    $37C80000, $37C88000, $37C90000, $37C98000, $37CA0000, $37CA8000, $37CB0000, $37CB8000,
    $37CC0000, $37CC8000, $37CD0000, $37CD8000, $37CE0000, $37CE8000, $37CF0000, $37CF8000,
    $37D00000, $37D08000, $37D10000, $37D18000, $37D20000, $37D28000, $37D30000, $37D38000,
    $37D40000, $37D48000, $37D50000, $37D58000, $37D60000, $37D68000, $37D70000, $37D78000,
    $37D80000, $37D88000, $37D90000, $37D98000, $37DA0000, $37DA8000, $37DB0000, $37DB8000,
    $37DC0000, $37DC8000, $37DD0000, $37DD8000, $37DE0000, $37DE8000, $37DF0000, $37DF8000,
    $37E00000, $37E08000, $37E10000, $37E18000, $37E20000, $37E28000, $37E30000, $37E38000,
    $37E40000, $37E48000, $37E50000, $37E58000, $37E60000, $37E68000, $37E70000, $37E78000,
    $37E80000, $37E88000, $37E90000, $37E98000, $37EA0000, $37EA8000, $37EB0000, $37EB8000,
    $37EC0000, $37EC8000, $37ED0000, $37ED8000, $37EE0000, $37EE8000, $37EF0000, $37EF8000,
    $37F00000, $37F08000, $37F10000, $37F18000, $37F20000, $37F28000, $37F30000, $37F38000,
    $37F40000, $37F48000, $37F50000, $37F58000, $37F60000, $37F68000, $37F70000, $37F78000,
    $37F80000, $37F88000, $37F90000, $37F98000, $37FA0000, $37FA8000, $37FB0000, $37FB8000,
    $37FC0000, $37FC8000, $37FD0000, $37FD8000, $37FE0000, $37FE8000, $37FF0000, $37FF8000,
    $38000000, $38004000, $38008000, $3800C000, $38010000, $38014000, $38018000, $3801C000,
    $38020000, $38024000, $38028000, $3802C000, $38030000, $38034000, $38038000, $3803C000,
    $38040000, $38044000, $38048000, $3804C000, $38050000, $38054000, $38058000, $3805C000,
    $38060000, $38064000, $38068000, $3806C000, $38070000, $38074000, $38078000, $3807C000,
    $38080000, $38084000, $38088000, $3808C000, $38090000, $38094000, $38098000, $3809C000,
    $380A0000, $380A4000, $380A8000, $380AC000, $380B0000, $380B4000, $380B8000, $380BC000,
    $380C0000, $380C4000, $380C8000, $380CC000, $380D0000, $380D4000, $380D8000, $380DC000,
    $380E0000, $380E4000, $380E8000, $380EC000, $380F0000, $380F4000, $380F8000, $380FC000,
    $38100000, $38104000, $38108000, $3810C000, $38110000, $38114000, $38118000, $3811C000,
    $38120000, $38124000, $38128000, $3812C000, $38130000, $38134000, $38138000, $3813C000,
    $38140000, $38144000, $38148000, $3814C000, $38150000, $38154000, $38158000, $3815C000,
    $38160000, $38164000, $38168000, $3816C000, $38170000, $38174000, $38178000, $3817C000,
    $38180000, $38184000, $38188000, $3818C000, $38190000, $38194000, $38198000, $3819C000,
    $381A0000, $381A4000, $381A8000, $381AC000, $381B0000, $381B4000, $381B8000, $381BC000,
    $381C0000, $381C4000, $381C8000, $381CC000, $381D0000, $381D4000, $381D8000, $381DC000,
    $381E0000, $381E4000, $381E8000, $381EC000, $381F0000, $381F4000, $381F8000, $381FC000,
    $38200000, $38204000, $38208000, $3820C000, $38210000, $38214000, $38218000, $3821C000,
    $38220000, $38224000, $38228000, $3822C000, $38230000, $38234000, $38238000, $3823C000,
    $38240000, $38244000, $38248000, $3824C000, $38250000, $38254000, $38258000, $3825C000,
    $38260000, $38264000, $38268000, $3826C000, $38270000, $38274000, $38278000, $3827C000,
    $38280000, $38284000, $38288000, $3828C000, $38290000, $38294000, $38298000, $3829C000,
    $382A0000, $382A4000, $382A8000, $382AC000, $382B0000, $382B4000, $382B8000, $382BC000,
    $382C0000, $382C4000, $382C8000, $382CC000, $382D0000, $382D4000, $382D8000, $382DC000,
    $382E0000, $382E4000, $382E8000, $382EC000, $382F0000, $382F4000, $382F8000, $382FC000,
    $38300000, $38304000, $38308000, $3830C000, $38310000, $38314000, $38318000, $3831C000,
    $38320000, $38324000, $38328000, $3832C000, $38330000, $38334000, $38338000, $3833C000,
    $38340000, $38344000, $38348000, $3834C000, $38350000, $38354000, $38358000, $3835C000,
    $38360000, $38364000, $38368000, $3836C000, $38370000, $38374000, $38378000, $3837C000,
    $38380000, $38384000, $38388000, $3838C000, $38390000, $38394000, $38398000, $3839C000,
    $383A0000, $383A4000, $383A8000, $383AC000, $383B0000, $383B4000, $383B8000, $383BC000,
    $383C0000, $383C4000, $383C8000, $383CC000, $383D0000, $383D4000, $383D8000, $383DC000,
    $383E0000, $383E4000, $383E8000, $383EC000, $383F0000, $383F4000, $383F8000, $383FC000,
    $38400000, $38404000, $38408000, $3840C000, $38410000, $38414000, $38418000, $3841C000,
    $38420000, $38424000, $38428000, $3842C000, $38430000, $38434000, $38438000, $3843C000,
    $38440000, $38444000, $38448000, $3844C000, $38450000, $38454000, $38458000, $3845C000,
    $38460000, $38464000, $38468000, $3846C000, $38470000, $38474000, $38478000, $3847C000,
    $38480000, $38484000, $38488000, $3848C000, $38490000, $38494000, $38498000, $3849C000,
    $384A0000, $384A4000, $384A8000, $384AC000, $384B0000, $384B4000, $384B8000, $384BC000,
    $384C0000, $384C4000, $384C8000, $384CC000, $384D0000, $384D4000, $384D8000, $384DC000,
    $384E0000, $384E4000, $384E8000, $384EC000, $384F0000, $384F4000, $384F8000, $384FC000,
    $38500000, $38504000, $38508000, $3850C000, $38510000, $38514000, $38518000, $3851C000,
    $38520000, $38524000, $38528000, $3852C000, $38530000, $38534000, $38538000, $3853C000,
    $38540000, $38544000, $38548000, $3854C000, $38550000, $38554000, $38558000, $3855C000,
    $38560000, $38564000, $38568000, $3856C000, $38570000, $38574000, $38578000, $3857C000,
    $38580000, $38584000, $38588000, $3858C000, $38590000, $38594000, $38598000, $3859C000,
    $385A0000, $385A4000, $385A8000, $385AC000, $385B0000, $385B4000, $385B8000, $385BC000,
    $385C0000, $385C4000, $385C8000, $385CC000, $385D0000, $385D4000, $385D8000, $385DC000,
    $385E0000, $385E4000, $385E8000, $385EC000, $385F0000, $385F4000, $385F8000, $385FC000,
    $38600000, $38604000, $38608000, $3860C000, $38610000, $38614000, $38618000, $3861C000,
    $38620000, $38624000, $38628000, $3862C000, $38630000, $38634000, $38638000, $3863C000,
    $38640000, $38644000, $38648000, $3864C000, $38650000, $38654000, $38658000, $3865C000,
    $38660000, $38664000, $38668000, $3866C000, $38670000, $38674000, $38678000, $3867C000,
    $38680000, $38684000, $38688000, $3868C000, $38690000, $38694000, $38698000, $3869C000,
    $386A0000, $386A4000, $386A8000, $386AC000, $386B0000, $386B4000, $386B8000, $386BC000,
    $386C0000, $386C4000, $386C8000, $386CC000, $386D0000, $386D4000, $386D8000, $386DC000,
    $386E0000, $386E4000, $386E8000, $386EC000, $386F0000, $386F4000, $386F8000, $386FC000,
    $38700000, $38704000, $38708000, $3870C000, $38710000, $38714000, $38718000, $3871C000,
    $38720000, $38724000, $38728000, $3872C000, $38730000, $38734000, $38738000, $3873C000,
    $38740000, $38744000, $38748000, $3874C000, $38750000, $38754000, $38758000, $3875C000,
    $38760000, $38764000, $38768000, $3876C000, $38770000, $38774000, $38778000, $3877C000,
    $38780000, $38784000, $38788000, $3878C000, $38790000, $38794000, $38798000, $3879C000,
    $387A0000, $387A4000, $387A8000, $387AC000, $387B0000, $387B4000, $387B8000, $387BC000,
    $387C0000, $387C4000, $387C8000, $387CC000, $387D0000, $387D4000, $387D8000, $387DC000,
    $387E0000, $387E4000, $387E8000, $387EC000, $387F0000, $387F4000, $387F8000, $387FC000,
    $38000000, $38002000, $38004000, $38006000, $38008000, $3800A000, $3800C000, $3800E000,
    $38010000, $38012000, $38014000, $38016000, $38018000, $3801A000, $3801C000, $3801E000,
    $38020000, $38022000, $38024000, $38026000, $38028000, $3802A000, $3802C000, $3802E000,
    $38030000, $38032000, $38034000, $38036000, $38038000, $3803A000, $3803C000, $3803E000,
    $38040000, $38042000, $38044000, $38046000, $38048000, $3804A000, $3804C000, $3804E000,
    $38050000, $38052000, $38054000, $38056000, $38058000, $3805A000, $3805C000, $3805E000,
    $38060000, $38062000, $38064000, $38066000, $38068000, $3806A000, $3806C000, $3806E000,
    $38070000, $38072000, $38074000, $38076000, $38078000, $3807A000, $3807C000, $3807E000,
    $38080000, $38082000, $38084000, $38086000, $38088000, $3808A000, $3808C000, $3808E000,
    $38090000, $38092000, $38094000, $38096000, $38098000, $3809A000, $3809C000, $3809E000,
    $380A0000, $380A2000, $380A4000, $380A6000, $380A8000, $380AA000, $380AC000, $380AE000,
    $380B0000, $380B2000, $380B4000, $380B6000, $380B8000, $380BA000, $380BC000, $380BE000,
    $380C0000, $380C2000, $380C4000, $380C6000, $380C8000, $380CA000, $380CC000, $380CE000,
    $380D0000, $380D2000, $380D4000, $380D6000, $380D8000, $380DA000, $380DC000, $380DE000,
    $380E0000, $380E2000, $380E4000, $380E6000, $380E8000, $380EA000, $380EC000, $380EE000,
    $380F0000, $380F2000, $380F4000, $380F6000, $380F8000, $380FA000, $380FC000, $380FE000,
    $38100000, $38102000, $38104000, $38106000, $38108000, $3810A000, $3810C000, $3810E000,
    $38110000, $38112000, $38114000, $38116000, $38118000, $3811A000, $3811C000, $3811E000,
    $38120000, $38122000, $38124000, $38126000, $38128000, $3812A000, $3812C000, $3812E000,
    $38130000, $38132000, $38134000, $38136000, $38138000, $3813A000, $3813C000, $3813E000,
    $38140000, $38142000, $38144000, $38146000, $38148000, $3814A000, $3814C000, $3814E000,
    $38150000, $38152000, $38154000, $38156000, $38158000, $3815A000, $3815C000, $3815E000,
    $38160000, $38162000, $38164000, $38166000, $38168000, $3816A000, $3816C000, $3816E000,
    $38170000, $38172000, $38174000, $38176000, $38178000, $3817A000, $3817C000, $3817E000,
    $38180000, $38182000, $38184000, $38186000, $38188000, $3818A000, $3818C000, $3818E000,
    $38190000, $38192000, $38194000, $38196000, $38198000, $3819A000, $3819C000, $3819E000,
    $381A0000, $381A2000, $381A4000, $381A6000, $381A8000, $381AA000, $381AC000, $381AE000,
    $381B0000, $381B2000, $381B4000, $381B6000, $381B8000, $381BA000, $381BC000, $381BE000,
    $381C0000, $381C2000, $381C4000, $381C6000, $381C8000, $381CA000, $381CC000, $381CE000,
    $381D0000, $381D2000, $381D4000, $381D6000, $381D8000, $381DA000, $381DC000, $381DE000,
    $381E0000, $381E2000, $381E4000, $381E6000, $381E8000, $381EA000, $381EC000, $381EE000,
    $381F0000, $381F2000, $381F4000, $381F6000, $381F8000, $381FA000, $381FC000, $381FE000,
    $38200000, $38202000, $38204000, $38206000, $38208000, $3820A000, $3820C000, $3820E000,
    $38210000, $38212000, $38214000, $38216000, $38218000, $3821A000, $3821C000, $3821E000,
    $38220000, $38222000, $38224000, $38226000, $38228000, $3822A000, $3822C000, $3822E000,
    $38230000, $38232000, $38234000, $38236000, $38238000, $3823A000, $3823C000, $3823E000,
    $38240000, $38242000, $38244000, $38246000, $38248000, $3824A000, $3824C000, $3824E000,
    $38250000, $38252000, $38254000, $38256000, $38258000, $3825A000, $3825C000, $3825E000,
    $38260000, $38262000, $38264000, $38266000, $38268000, $3826A000, $3826C000, $3826E000,
    $38270000, $38272000, $38274000, $38276000, $38278000, $3827A000, $3827C000, $3827E000,
    $38280000, $38282000, $38284000, $38286000, $38288000, $3828A000, $3828C000, $3828E000,
    $38290000, $38292000, $38294000, $38296000, $38298000, $3829A000, $3829C000, $3829E000,
    $382A0000, $382A2000, $382A4000, $382A6000, $382A8000, $382AA000, $382AC000, $382AE000,
    $382B0000, $382B2000, $382B4000, $382B6000, $382B8000, $382BA000, $382BC000, $382BE000,
    $382C0000, $382C2000, $382C4000, $382C6000, $382C8000, $382CA000, $382CC000, $382CE000,
    $382D0000, $382D2000, $382D4000, $382D6000, $382D8000, $382DA000, $382DC000, $382DE000,
    $382E0000, $382E2000, $382E4000, $382E6000, $382E8000, $382EA000, $382EC000, $382EE000,
    $382F0000, $382F2000, $382F4000, $382F6000, $382F8000, $382FA000, $382FC000, $382FE000,
    $38300000, $38302000, $38304000, $38306000, $38308000, $3830A000, $3830C000, $3830E000,
    $38310000, $38312000, $38314000, $38316000, $38318000, $3831A000, $3831C000, $3831E000,
    $38320000, $38322000, $38324000, $38326000, $38328000, $3832A000, $3832C000, $3832E000,
    $38330000, $38332000, $38334000, $38336000, $38338000, $3833A000, $3833C000, $3833E000,
    $38340000, $38342000, $38344000, $38346000, $38348000, $3834A000, $3834C000, $3834E000,
    $38350000, $38352000, $38354000, $38356000, $38358000, $3835A000, $3835C000, $3835E000,
    $38360000, $38362000, $38364000, $38366000, $38368000, $3836A000, $3836C000, $3836E000,
    $38370000, $38372000, $38374000, $38376000, $38378000, $3837A000, $3837C000, $3837E000,
    $38380000, $38382000, $38384000, $38386000, $38388000, $3838A000, $3838C000, $3838E000,
    $38390000, $38392000, $38394000, $38396000, $38398000, $3839A000, $3839C000, $3839E000,
    $383A0000, $383A2000, $383A4000, $383A6000, $383A8000, $383AA000, $383AC000, $383AE000,
    $383B0000, $383B2000, $383B4000, $383B6000, $383B8000, $383BA000, $383BC000, $383BE000,
    $383C0000, $383C2000, $383C4000, $383C6000, $383C8000, $383CA000, $383CC000, $383CE000,
    $383D0000, $383D2000, $383D4000, $383D6000, $383D8000, $383DA000, $383DC000, $383DE000,
    $383E0000, $383E2000, $383E4000, $383E6000, $383E8000, $383EA000, $383EC000, $383EE000,
    $383F0000, $383F2000, $383F4000, $383F6000, $383F8000, $383FA000, $383FC000, $383FE000,
    $38400000, $38402000, $38404000, $38406000, $38408000, $3840A000, $3840C000, $3840E000,
    $38410000, $38412000, $38414000, $38416000, $38418000, $3841A000, $3841C000, $3841E000,
    $38420000, $38422000, $38424000, $38426000, $38428000, $3842A000, $3842C000, $3842E000,
    $38430000, $38432000, $38434000, $38436000, $38438000, $3843A000, $3843C000, $3843E000,
    $38440000, $38442000, $38444000, $38446000, $38448000, $3844A000, $3844C000, $3844E000,
    $38450000, $38452000, $38454000, $38456000, $38458000, $3845A000, $3845C000, $3845E000,
    $38460000, $38462000, $38464000, $38466000, $38468000, $3846A000, $3846C000, $3846E000,
    $38470000, $38472000, $38474000, $38476000, $38478000, $3847A000, $3847C000, $3847E000,
    $38480000, $38482000, $38484000, $38486000, $38488000, $3848A000, $3848C000, $3848E000,
    $38490000, $38492000, $38494000, $38496000, $38498000, $3849A000, $3849C000, $3849E000,
    $384A0000, $384A2000, $384A4000, $384A6000, $384A8000, $384AA000, $384AC000, $384AE000,
    $384B0000, $384B2000, $384B4000, $384B6000, $384B8000, $384BA000, $384BC000, $384BE000,
    $384C0000, $384C2000, $384C4000, $384C6000, $384C8000, $384CA000, $384CC000, $384CE000,
    $384D0000, $384D2000, $384D4000, $384D6000, $384D8000, $384DA000, $384DC000, $384DE000,
    $384E0000, $384E2000, $384E4000, $384E6000, $384E8000, $384EA000, $384EC000, $384EE000,
    $384F0000, $384F2000, $384F4000, $384F6000, $384F8000, $384FA000, $384FC000, $384FE000,
    $38500000, $38502000, $38504000, $38506000, $38508000, $3850A000, $3850C000, $3850E000,
    $38510000, $38512000, $38514000, $38516000, $38518000, $3851A000, $3851C000, $3851E000,
    $38520000, $38522000, $38524000, $38526000, $38528000, $3852A000, $3852C000, $3852E000,
    $38530000, $38532000, $38534000, $38536000, $38538000, $3853A000, $3853C000, $3853E000,
    $38540000, $38542000, $38544000, $38546000, $38548000, $3854A000, $3854C000, $3854E000,
    $38550000, $38552000, $38554000, $38556000, $38558000, $3855A000, $3855C000, $3855E000,
    $38560000, $38562000, $38564000, $38566000, $38568000, $3856A000, $3856C000, $3856E000,
    $38570000, $38572000, $38574000, $38576000, $38578000, $3857A000, $3857C000, $3857E000,
    $38580000, $38582000, $38584000, $38586000, $38588000, $3858A000, $3858C000, $3858E000,
    $38590000, $38592000, $38594000, $38596000, $38598000, $3859A000, $3859C000, $3859E000,
    $385A0000, $385A2000, $385A4000, $385A6000, $385A8000, $385AA000, $385AC000, $385AE000,
    $385B0000, $385B2000, $385B4000, $385B6000, $385B8000, $385BA000, $385BC000, $385BE000,
    $385C0000, $385C2000, $385C4000, $385C6000, $385C8000, $385CA000, $385CC000, $385CE000,
    $385D0000, $385D2000, $385D4000, $385D6000, $385D8000, $385DA000, $385DC000, $385DE000,
    $385E0000, $385E2000, $385E4000, $385E6000, $385E8000, $385EA000, $385EC000, $385EE000,
    $385F0000, $385F2000, $385F4000, $385F6000, $385F8000, $385FA000, $385FC000, $385FE000,
    $38600000, $38602000, $38604000, $38606000, $38608000, $3860A000, $3860C000, $3860E000,
    $38610000, $38612000, $38614000, $38616000, $38618000, $3861A000, $3861C000, $3861E000,
    $38620000, $38622000, $38624000, $38626000, $38628000, $3862A000, $3862C000, $3862E000,
    $38630000, $38632000, $38634000, $38636000, $38638000, $3863A000, $3863C000, $3863E000,
    $38640000, $38642000, $38644000, $38646000, $38648000, $3864A000, $3864C000, $3864E000,
    $38650000, $38652000, $38654000, $38656000, $38658000, $3865A000, $3865C000, $3865E000,
    $38660000, $38662000, $38664000, $38666000, $38668000, $3866A000, $3866C000, $3866E000,
    $38670000, $38672000, $38674000, $38676000, $38678000, $3867A000, $3867C000, $3867E000,
    $38680000, $38682000, $38684000, $38686000, $38688000, $3868A000, $3868C000, $3868E000,
    $38690000, $38692000, $38694000, $38696000, $38698000, $3869A000, $3869C000, $3869E000,
    $386A0000, $386A2000, $386A4000, $386A6000, $386A8000, $386AA000, $386AC000, $386AE000,
    $386B0000, $386B2000, $386B4000, $386B6000, $386B8000, $386BA000, $386BC000, $386BE000,
    $386C0000, $386C2000, $386C4000, $386C6000, $386C8000, $386CA000, $386CC000, $386CE000,
    $386D0000, $386D2000, $386D4000, $386D6000, $386D8000, $386DA000, $386DC000, $386DE000,
    $386E0000, $386E2000, $386E4000, $386E6000, $386E8000, $386EA000, $386EC000, $386EE000,
    $386F0000, $386F2000, $386F4000, $386F6000, $386F8000, $386FA000, $386FC000, $386FE000,
    $38700000, $38702000, $38704000, $38706000, $38708000, $3870A000, $3870C000, $3870E000,
    $38710000, $38712000, $38714000, $38716000, $38718000, $3871A000, $3871C000, $3871E000,
    $38720000, $38722000, $38724000, $38726000, $38728000, $3872A000, $3872C000, $3872E000,
    $38730000, $38732000, $38734000, $38736000, $38738000, $3873A000, $3873C000, $3873E000,
    $38740000, $38742000, $38744000, $38746000, $38748000, $3874A000, $3874C000, $3874E000,
    $38750000, $38752000, $38754000, $38756000, $38758000, $3875A000, $3875C000, $3875E000,
    $38760000, $38762000, $38764000, $38766000, $38768000, $3876A000, $3876C000, $3876E000,
    $38770000, $38772000, $38774000, $38776000, $38778000, $3877A000, $3877C000, $3877E000,
    $38780000, $38782000, $38784000, $38786000, $38788000, $3878A000, $3878C000, $3878E000,
    $38790000, $38792000, $38794000, $38796000, $38798000, $3879A000, $3879C000, $3879E000,
    $387A0000, $387A2000, $387A4000, $387A6000, $387A8000, $387AA000, $387AC000, $387AE000,
    $387B0000, $387B2000, $387B4000, $387B6000, $387B8000, $387BA000, $387BC000, $387BE000,
    $387C0000, $387C2000, $387C4000, $387C6000, $387C8000, $387CA000, $387CC000, $387CE000,
    $387D0000, $387D2000, $387D4000, $387D6000, $387D8000, $387DA000, $387DC000, $387DE000,
    $387E0000, $387E2000, $387E4000, $387E6000, $387E8000, $387EA000, $387EC000, $387EE000,
    $387F0000, $387F2000, $387F4000, $387F6000, $387F8000, $387FA000, $387FC000, $387FE000);

const
  EXPONENT_TABLE: array [0..63] of UInt32 = (
    $00000000, $00800000, $01000000, $01800000, $02000000, $02800000, $03000000, $03800000,
    $04000000, $04800000, $05000000, $05800000, $06000000, $06800000, $07000000, $07800000,
    $08000000, $08800000, $09000000, $09800000, $0A000000, $0A800000, $0B000000, $0B800000,
    $0C000000, $0C800000, $0D000000, $0D800000, $0E000000, $0E800000, $0F000000, $47800000,
    $80000000, $80800000, $81000000, $81800000, $82000000, $82800000, $83000000, $83800000,
    $84000000, $84800000, $85000000, $85800000, $86000000, $86800000, $87000000, $87800000,
    $88000000, $88800000, $89000000, $89800000, $8A000000, $8A800000, $8B000000, $8B800000,
    $8C000000, $8C800000, $8D000000, $8D800000, $8E000000, $8E800000, $8F000000, $C7800000);

const
  OFFSET_TABLE: array [0..63] of UInt16 = (
       0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
    1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
       0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
    1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024);

const
  BASE_TABLE: array [0..511] of UInt16 = (
    $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000,
    $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000,
    $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000,
    $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000,
    $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000,
    $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000,
    $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000,
    $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000,
    $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000,
    $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000,
    $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000,
    $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0000,
    $0000, $0000, $0000, $0000, $0000, $0000, $0000, $0001,
    $0002, $0004, $0008, $0010, $0020, $0040, $0080, $0100,
    $0200, $0400, $0800, $0C00, $1000, $1400, $1800, $1C00,
    $2000, $2400, $2800, $2C00, $3000, $3400, $3800, $3C00,
    $4000, $4400, $4800, $4C00, $5000, $5400, $5800, $5C00,
    $6000, $6400, $6800, $6C00, $7000, $7400, $7800, $7C00,
    $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00,
    $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00,
    $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00,
    $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00,
    $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00,
    $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00,
    $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00,
    $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00,
    $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00,
    $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00,
    $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00,
    $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00,
    $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00,
    $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00, $7C00,
    $8000, $8000, $8000, $8000, $8000, $8000, $8000, $8000,
    $8000, $8000, $8000, $8000, $8000, $8000, $8000, $8000,
    $8000, $8000, $8000, $8000, $8000, $8000, $8000, $8000,
    $8000, $8000, $8000, $8000, $8000, $8000, $8000, $8000,
    $8000, $8000, $8000, $8000, $8000, $8000, $8000, $8000,
    $8000, $8000, $8000, $8000, $8000, $8000, $8000, $8000,
    $8000, $8000, $8000, $8000, $8000, $8000, $8000, $8000,
    $8000, $8000, $8000, $8000, $8000, $8000, $8000, $8000,
    $8000, $8000, $8000, $8000, $8000, $8000, $8000, $8000,
    $8000, $8000, $8000, $8000, $8000, $8000, $8000, $8000,
    $8000, $8000, $8000, $8000, $8000, $8000, $8000, $8000,
    $8000, $8000, $8000, $8000, $8000, $8000, $8000, $8000,
    $8000, $8000, $8000, $8000, $8000, $8000, $8000, $8001,
    $8002, $8004, $8008, $8010, $8020, $8040, $8080, $8100,
    $8200, $8400, $8800, $8C00, $9000, $9400, $9800, $9C00,
    $A000, $A400, $A800, $AC00, $B000, $B400, $B800, $BC00,
    $C000, $C400, $C800, $CC00, $D000, $D400, $D800, $DC00,
    $E000, $E400, $E800, $EC00, $F000, $F400, $F800, $FC00,
    $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00,
    $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00,
    $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00,
    $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00,
    $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00,
    $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00,
    $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00,
    $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00,
    $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00,
    $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00,
    $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00,
    $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00,
    $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00,
    $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00, $FC00);

const
  SHIFT_TABLE: array [0..511] of Byte = (
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15,
    14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15,
    14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13);

const    
  LOG2_TABLE: array [0..255] of Int8 = (
   -1, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7);

function Log2(const AValue: Cardinal): Integer;
{ https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogLookup }
var
  T1, T2: Cardinal;
begin
  T1 := (AValue shr 16);
  if (T1 <> 0) then
  begin
    T2 := T1 shr 8;
    if (T2 <> 0) then
      Result := 24 + LOG2_TABLE[T2]
    else
      Result := 16 + LOG2_TABLE[T1];
  end
  else
  begin
    T2 := AValue shr 8;
    if (T2 <> 0) then
      Result := 8 + LOG2_TABLE[T2]
    else
      Result := LOG2_TABLE[AValue];
  end;
end;

function GetSmallestFloatType(const AValue: Double): TFloatType;
var
  Bits: Int64 absolute AValue;
  Exponent: Integer;
  Mantissa: Int64;
begin
  Exponent := (Bits shr 52) and $07FF;    // 11 bits
  Mantissa := Bits and $000FFFFFFFFFFFFF; // 52 bits

  if (Exponent = $07FF) then
    // +/-Infinity, NaN, fits into Half
    Exit(TFloatType.Half);

  if (Exponent = 0) then
  begin
    if (Mantissa = 0) then
      // Zero, fits into Half
      Exit(TFloatType.Half)
    else
    begin
      // Subnormals
      if ((Mantissa and $000003FFFFFFFFFF) = 0) then
        // Lowest 42 bits are 0 (upper 10 bits fit into Half)
        Exit(TFloatType.Half)
      else if ((Mantissa and $000000001FFFFFFF) = 0) then
        // Lowest 29 bits are 0 (upper 23 bits fit into Single)
        Exit(TFloatType.Single)
      else
        // Does not fit into Half or Single
        Exit(TFloatType.Double);
    end;
  end;

  // Normalized values
  Dec(Exponent, 1023);
  if (Exponent < -126) or (Exponent > 127) then
    // Exponent too large for Half or Single
    Exit(TFloatType.Double);

  if ((Mantissa and $000000001FFFFFFF) <> 0) then
    // Mantissa too large for Half or Single
    Exit(TFloatType.Double);

  // Now, AValue fits into a Single. Check if it fits into a Half.
  if (Exponent < -14) or (Exponent > 15) then
    // Exponent too large for Half
    Exit(TFloatType.Single);

  if ((Mantissa and $000003FFFFFFFFFF) = 0) then
    Result := TFloatType.Half
  else
    Result := TFloatType.Single;
end;

{ Half }

class operator Half.Add(const ALeft, ARight: Half): Half;
begin
  Result := Single(ALeft) + Single(ARight);
end;

class operator Half.Divide(const ALeft, ARight: Half): Half;
begin
  Result := Single(ALeft) / Single(ARight);
end;

class operator Half.Equal(const ALeft, ARight: Half): Boolean;
begin
  Result := ((ALeft.FData = ARight.FData)                    // Same value
        or (((ALeft.FData or ARight.FData) and $7FFF) = 0))  // Zero (positive or negative)
        and (not ALeft.IsNan);
end;

class operator Half.Explicit(const AValue: Half): UInt16;
var
  Val: Integer;
begin
  Val := Trunc(AValue);
  if (Val < Word.MinValue) then
    Result := Word.MinValue
  else if (Val > Word.MaxValue) then
    Result := Word.MaxValue
  else
    Result := Val;
end;

class operator Half.Explicit(const AValue: Half): Int16;
var
  Val: Integer;
begin
  Val := Trunc(AValue);
  if (Val < Smallint.MinValue) then
    Result := Smallint.MinValue
  else if (Val > Smallint.MaxValue) then
    Result := Smallint.MaxValue
  else
    Result := Val;
end;

class operator Half.Explicit(const AValue: Half): UInt8;
var
  Val: Integer;
begin
  Val := Trunc(AValue);
  if (Val < Byte.MinValue) then
    Result := Byte.MinValue
  else if (Val > Byte.MaxValue) then
    Result := Byte.MaxValue
  else
    Result := Val;
end;

class operator Half.Explicit(const AValue: Half): Int8;
var
  Val: Integer;
begin
  Val := Trunc(AValue);
  if (Val < Shortint.MinValue) then
    Result := Shortint.MinValue
  else if (Val > Shortint.MaxValue) then
    Result := Shortint.MaxValue
  else
    Result := Val;
end;

class operator Half.Explicit(const AValue: Half): UInt64;
var
  Val: Int64;
begin
  Val := TruncInt64(AValue);
  if (Val < 0) then
    Result := 0
  else if (Val = Int64.MaxValue) then
    Result := UInt64.MaxValue
  else
    Result := Val;
end;

class operator Half.Explicit(const AValue: Half): Int64;
begin
  Result := TruncInt64(AValue);
end;

class operator Half.Explicit(const AValue: Half): UInt32;
var
  Val: Int64;
begin
  Val := TruncInt64(AValue);
  if (Val < Cardinal.MinValue) then
    Result := Cardinal.MinValue
  else if (Val > Cardinal.MaxValue) then
    Result := Cardinal.MaxValue
  else
    Result := Val;
end;

class operator Half.Explicit(const AValue: Half): Int32;
begin
  Result := Trunc(AValue);
end;

class operator Half.GreaterThan(const ALeft, ARight: Half): Boolean;
var
  L, R: Integer;
begin
  L := ALeft.FData and $7FFF; // Absolute value
  R := ARight.FData and $7FFF;
  if (L > $7C00) or (R > $7C00) then
    Exit(False); // NaN

  if (L <> ALeft.FData) then // Convert to signed integer
    L := -L;

  if (R <> ARight.FData) then // Convert to signed integer
    R := -R;

  Result := (L > R);
end;

class operator Half.GreaterThanOrEqual(const ALeft, ARight: Half): Boolean;
var
  L, R: Integer;
begin
  L := ALeft.FData and $7FFF; // Absolute value
  R := ARight.FData and $7FFF;
  if (L > $7C00) or (R > $7C00) then
    Exit(False); // NaN

  if (L <> ALeft.FData) then // Convert to signed integer
    L := -L;

  if (R <> ARight.FData) then // Convert to signed integer
    R := -R;

  Result := (L >= R);
end;

class operator Half.Implicit(const AValue: Int8): Half;
begin
  Result.FData := Int32ToHalf(AValue);
end;

class operator Half.Implicit(const AValue: UInt8): Half;
begin
  Result.FData := UInt32ToHalf(AValue);
end;

class operator Half.Implicit(const AValue: UInt16): Half;
begin
  Result.FData := UInt32ToHalf(AValue);
end;

class operator Half.Implicit(const AValue: Int16): Half;
begin
  Result.FData := Int32ToHalf(AValue);
end;

class operator Half.Implicit(const AValue: Int32): Half;
begin
  Result.FData := Int32ToHalf(AValue);
end;

class operator Half.Implicit(const AValue: UInt32): Half;
begin
  Result.FData := UInt32ToHalf(AValue);
end;

class operator Half.Implicit(const AValue: Int64): Half;
begin
  Result.FData := Int64ToHalf(AValue);
end;

class operator Half.Implicit(const AValue: UInt64): Half;
begin
  Result.FData := UInt64ToHalf(AValue);
end;

class operator Half.Implicit(const AValue: Half): Single;
{ Algorithm from Jeroen van der Zijp's paper }
var
  Bits: UInt32 absolute Result;
  ExpSign: UInt32;
begin
  ExpSign := AValue.FData shr 10;
  Bits := MANTISSA_TABLE[OFFSET_TABLE[ExpSign]
        + (AValue.FData and $03FF)]
        + EXPONENT_TABLE[ExpSign];
end;

class operator Half.Implicit(const AValue: Half): Double;
begin
  Result := Single(AValue);
end;

class operator Half.Implicit(const AValue: Double): Half;
var
  Bits: UInt64 absolute AValue;
  Exp: Int32;
begin
  Exp := ((Bits shr 52) and $07FF) - 1023;
  if (Exp < -126) then
    { Exponent to small to be represented by a Half }
    Result.FData := 0
  else if (Exp > 127) then
  begin
    { Exponent to large to be represented by a Half.
      Result is either +/-Infinity or NaN, depending on the sign and value
      of AValue. }
    if (Exp = 1024) and ((Bits and $000FFFFFFFFFFFFF) <> 0) then
      Result := Half.NaN
    else if ((Bits and $8000000000000000) = 0) then
      Result := Half.PositiveInfinity
    else
      Result := Half.NegativeInfinity
  end
  else
    Result := Single(AValue);
end;

class operator Half.Implicit(const AValue: Single): Half;
{ Algorithm from Jeroen van der Zijp's paper }
var
  Bits: UInt32 absolute AValue;
  ExpSign: UInt32;
begin
  ExpSign := Bits shr 23;
  Result.FData := BASE_TABLE[ExpSign]
                + ((Bits and $007FFFFF) shr SHIFT_TABLE[ExpSign]);
end;

class function Half.Int32ToHalf(AValue: Int32): UInt16;
var
  Exponent: Integer;
begin
  Result := 0;
  if (AValue < 0) then
  begin
    { Set sign bit }
    Result := $8000;
    AValue := -AValue;
  end;

  if (AValue >= $10000) then
    { Value to big. Set result to +/- Infinity }
    Result := Result or $7C00
  else if (AValue <> 0) then
  begin
    { The exponent is the Log2 of the value, and will range from 0 (for value 1)
      to 15 (for values $8000-$FFFF) }
    Exponent := Log2(AValue);

    { We have 11 bits for the mantissa (including the implicit leading 1 bit).
      This can hold any value with an exponent of 10 (1024-2047). For smaller
      exponents, the value must be left-shifted to get the mantissa. For larger
      exponents, the value must be right-shifted to fit into 11 bits. }
    if (Exponent < 10) then
      AValue := AValue shl (10 - Exponent)
    else // if (Exponent > 10) then
      AValue := AValue shr (Exponent - 10);
      
    { Add the exponent bias }
    Inc(Exponent, 15);

    { Remove the explicit leading 1 bit }
    AValue := AValue and $3FF;

    { Encode to Half precision }
    Result := Result or ((Exponent shl 10) + AValue);
  end;
end;

class function Half.Int64ToHalf(AValue: Int64): UInt16;
var
  Exponent: Integer;
begin
  Result := 0;
  if (AValue < 0) then
  begin
    { Set sign bit }
    Result := $8000;
    AValue := -AValue;
  end;

  if (AValue >= $10000) then
    { Value to big. Set result to +/- Infinity }
    Result := Result or $7C00
  else if (AValue <> 0) then
  begin
    { The exponent is the Log2 of the value, and will range from 0 (for value 1)
      to 15 (for values $8000-$FFFF) }
    Exponent := Log2(AValue);

    { We have 11 bits for the mantissa (including the implicit leading 1 bit).
      This can hold any value with an exponent of 10 (1024-2047). For smaller
      exponents, the value must be left-shifted to get the mantissa. For larger
      exponents, the value must be right-shifted to fit into 11 bits. }
    if (Exponent < 10) then
      AValue := AValue shl (10 - Exponent)
    else // if (Exponent > 10) then
      AValue := AValue shr (Exponent - 10);
      
    { Add the exponent bias }
    Inc(Exponent, 15);

    { Remove the explicit leading 1 bit }
    AValue := AValue and $3FF;

    { Encode to Half precision }
    Result := Result or ((Exponent shl 10) + AValue);
  end;
end;

class operator Half.LessThan(const ALeft, ARight: Half): Boolean;
var
  L, R: Integer;
begin
  L := ALeft.FData and $7FFF; // Absolute value
  R := ARight.FData and $7FFF;
  if (L > $7C00) or (R > $7C00) then
    Exit(False); // NaN

  if (L <> ALeft.FData) then // Convert to signed integer
    L := -L;

  if (R <> ARight.FData) then // Convert to signed integer
    R := -R;

  Result := (L < R);
end;

class operator Half.LessThanOrEqual(const ALeft, ARight: Half): Boolean;
var
  L, R: Integer;
begin
  L := ALeft.FData and $7FFF; // Absolute value
  R := ARight.FData and $7FFF;
  if (L > $7C00) or (R > $7C00) then
    Exit(False); // NaN

  if (L <> ALeft.FData) then // Convert to signed integer
    L := -L;

  if (R <> ARight.FData) then // Convert to signed integer
    R := -R;

  Result := (L <= R);
end;

class operator Half.Multiply(const ALeft, ARight: Half): Half;
begin
  Result := Single(ALeft) * Single(ARight);
end;

class operator Half.Negative(const AValue: Half): Half;
begin
  Result.FData := AValue.FData xor $8000;
end;

class operator Half.NotEqual(const ALeft, ARight: Half): Boolean;
begin
  Result := not (ALeft = ARight);
end;

class operator Half.Positive(const AValue: Half): Half;
begin
  Result := AValue;
end;

class operator Half.Round(const AValue: Half): Integer;
var
  Exponent: Integer;
begin
  Exponent := ((AValue.FData shr 10) and $1F) - 15;
  if (Exponent < -1) then
    { All values > -0.5 and < 0.5 }
    Exit(0)
  else if (Exponent = 16) then
  begin
    { +/- Infinity (we treats NaN as infinity as well) }
    if ((AValue.FData and $8000) <> 0) then
      Exit(Integer.MinValue)
    else
      Exit(Integer.MaxValue);
  end;

  { Calculate mantissa with explit leading 1 bit, for an 11-bit mantissa. }
  Result := (AValue.FData and $03FF) or $0400;

  { The 11-bit mantissa can hold any value with an exponent of 10 (1024-2047).
    For smaller exponents, we must right-shift the mantissa to get the integer
    value, and adjust for rounding. For larger exponents, we must left-shift the
    mantissa. }
  if (Exponent < 10) then
  begin
    Inc(Result, 1 shl (9 - Exponent));
    Result := Result shr (10 - Exponent);
  end
  else // if (Exponent > 10) then
    Result := Result shl (Exponent - 10);

  { Adjust for sign bit }
  if ((AValue.FData and $8000) <> 0) then
    Result := -Result;
end;

class operator Half.Subtract(const ALeft, ARight: Half): Half;
begin
  Result := Single(ALeft) - Single(ARight);
end;

class operator Half.Trunc(const AValue: Half): Integer;
var
  Exponent: Integer;
begin
  Exponent := ((AValue.FData shr 10) and $1F) - 15;
  if (Exponent < 0) then
    { All values > -1 and < 1 }
    Exit(0)
  else if (Exponent = 16) then
  begin
    { +/- Infinity (we treats NaN as infinity as well) }
    if ((AValue.FData and $8000) <> 0) then
      Exit(Integer.MinValue)
    else
      Exit(Integer.MaxValue);
  end;

  { Calculate mantissa with explit leading 1 bit, for an 11-bit mantissa. }
  Result := (AValue.FData and $03FF) or $0400;

  { The 11-bit mantissa can hold any value with an exponent of 10 (1024-2047).
    For smaller exponents, we must right-shift the mantissa to get the integer
    value. For larger exponents, we must left-shift the mantissa. }
  if (Exponent < 10) then
    Result := Result shr (10 - Exponent)
  else // if (Exponent > 10) then
    Result := Result shl (Exponent - 10);

  { Adjust for sign bit }
  if ((AValue.FData and $8000) <> 0) then
    Result := -Result;
end;

class function Half.TruncInt64(const AValue: Half): Int64;
var
  Exponent: Integer;
begin
  Exponent := ((AValue.FData shr 10) and $1F) - 15;
  if (Exponent < 0) then
    { All values > -1 and < 1 }
    Exit(0)
  else if (Exponent = 16) then
  begin
    { +/- Infinity (we treats NaN as infinity as well) }
    if ((AValue.FData and $8000) <> 0) then
      Exit(Int64.MinValue)
    else
      Exit(Int64.MaxValue);
  end;

  { Calculate mantissa with explit leading 1 bit, for an 11-bit mantissa. }
  Result := (AValue.FData and $03FF) or $0400;

  { The 11-bit mantissa can hold any value with an exponent of 10 (1024-2047).
    For smaller exponents, we must right-shift the mantissa to get the integer
    value. For larger exponents, we must left-shift the mantissa. }
  if (Exponent < 10) then
    Result := Result shr (10 - Exponent)
  else // if (Exponent > 10) then
    Result := Result shl (Exponent - 10);

  { Adjust for sign bit }
  if ((AValue.FData and $8000) <> 0) then
    Result := -Result;
end;

class function Half.UInt32ToHalf(AValue: UInt32): UInt16;
var
  Exponent: Cardinal;
begin
  Result := 0;
  if (AValue >= $10000) then
    { Value to big. Set result to +/- Infinity }
    Result := $7C00
  else if (AValue <> 0) then
  begin
    { The exponent is the Log2 of the value, and will range from 0 (for value 1)
      to 15 (for values $8000-$FFFF) }
    Exponent := Log2(AValue);

    { We have 11 bits for the mantissa (including the implicit leading 1 bit).
      This can hold any value with an exponent of 10 (1024-2047). For smaller
      exponents, the value must be left-shifted to get the mantissa. For larger
      exponents, the value must be right-shifted to fit into 11 bits. }
    if (Exponent < 10) then
      AValue := AValue shl (10 - Exponent)
    else // if (Exponent > 10) then
      AValue := AValue shr (Exponent - 10);

    { Add the exponent bias }
    Inc(Exponent, 15);

    { Remove the explicit leading 1 bit }
    AValue := AValue and $3FF;

    { Encode to Half precision }
    Result := (Exponent shl 10) + AValue;
  end;
end;

class function Half.UInt64ToHalf(AValue: UInt64): UInt16;
var
  Exponent: Cardinal;
begin
  Result := 0;
  if (AValue >= $10000) then
    { Value to big. Set result to +/- Infinity }
    Result := $7C00
  else if (AValue <> 0) then
  begin
    { The exponent is the Log2 of the value, and will range from 0 (for value 1)
      to 15 (for values $8000-$FFFF) }
    Exponent := Log2(AValue);

    { We have 11 bits for the mantissa (including the implicit leading 1 bit).
      This can hold any value with an exponent of 10 (1024-2047). For smaller
      exponents, the value must be left-shifted to get the mantissa. For larger
      exponents, the value must be right-shifted to fit into 11 bits. }
    if (Exponent < 10) then
      AValue := AValue shl (10 - Exponent)
    else // if (Exponent > 10) then
      AValue := AValue shr (Exponent - 10);

    { Add the exponent bias }
    Inc(Exponent, 15);

    { Remove the explicit leading 1 bit }
    AValue := AValue and $3FF;

    { Encode to Half precision }
    Result := (Exponent shl 10) + AValue;
  end;
end;

{ THalfHelper }

procedure THalfHelper.BuildUp(const ASignFlag: Boolean;
  const AMantissa: Cardinal; const AExponent: Integer);
begin
  Self := 0.0;
  Self.Sign := ASignFlag;
  Self.Exp := AExponent + 15;
  Self.Frac := AMantissa and $03FF;
end;

function THalfHelper.Exponent: Integer;
var
  E: Cardinal;
begin
  E := GetExp;
  if (E > 0) and (E < $1F) then
    Result := E - 15
  else if (GetFrac <> 0) then
    Result := -14 // Denormal, NaN
  else
    Result := 0; // Zero, Inf
end;

function THalfHelper.Fraction: Extended;
var
  E, F: Cardinal;
begin
  E := GetExp;
  F := GetFrac;
  if (E = $1F) then
  begin
    if (F = 0) then
      Result := Extended.PositiveInfinity
    else
      Result := Extended.NaN;
  end else if (E = 0) then
    Result := F / $0400
  else
    Result := 1.0 + (F / $0400);
end;

function THalfHelper.GetBytes(const AIndex: Integer): Byte;
var
  B: array [0..1] of Byte absolute Self;
begin
  if (Cardinal(AIndex) >= 2) then
    Error(reRangeError);
  Result := B[AIndex];
end;

function THalfHelper.GetExp: Cardinal;
begin
  Result := (FData shr 10) and $1F;
end;

function THalfHelper.GetFrac: Cardinal;
begin
  Result := FData and $03FF;
end;

function THalfHelper.GetSign: Boolean;
begin
  Result := (FData >= $8000);
end;

function THalfHelper.GetWords(const AIndex: Integer): Word;
begin
  if (AIndex <> 0) then
    Error(reRangeError);
  Result := FData;
end;

class function THalfHelper.IsInfinity(const AValue: Half): Boolean;
begin
  Result := AValue.IsInfinity;
end;

function THalfHelper.IsInfinity: Boolean;
begin
  Result := ((FData and $7FFF) = $7C00);
end;

class function THalfHelper.IsNan(const AValue: Half): Boolean;
begin
  Result := AValue.IsNan;
end;

function THalfHelper.IsNan: Boolean;
begin
  { $7C00=Infinity, >$7C00=NaN }
  Result := ((FData and $7FFF) > $7C00);
end;

class function THalfHelper.IsNegativeInfinity(const AValue: Half): Boolean;
begin
  Result := AValue.IsNegativeInfinity;
end;

function THalfHelper.IsNegativeInfinity: Boolean;
begin
  Result := (FData = $FC00);
end;

class function THalfHelper.IsPositiveInfinity(const AValue: Half): Boolean;
begin
  Result := AValue.IsPositiveInfinity;
end;

function THalfHelper.IsPositiveInfinity: Boolean;
begin
  Result := (FData = $7C00);
end;

function THalfHelper.Mantissa: Cardinal;
var
  E: Cardinal;
begin
  E := GetExp;
  Result := GetFrac;
  if (E > 0) and (E < $1F) then
    Result := Result or (1 shl 10);
end;

procedure THalfHelper.SetBytes(const AIndex: Integer; const AValue: Byte);
var
  B: array [0..1] of Byte absolute Self;
begin
  if (Cardinal(AIndex) >= 2) then
    Error(reRangeError);
  B[AIndex] := AValue;
end;

procedure THalfHelper.SetExp(const AValue: Cardinal);
begin
  FData := (FData and $83FF) or ((AValue and $1F) shl 10);
end;

procedure THalfHelper.SetFrac(const AValue: Cardinal);
begin
  FData := (FData and $FC00) or (AValue and $03FF);
end;

procedure THalfHelper.SetSign(const AValue: Boolean);
begin
  if (AValue) then
    FData := FData or $8000
  else
    FData := FData and $7FFF;
end;

procedure THalfHelper.SetWords(const AIndex: Integer; const AValue: Word);
begin
  if (AIndex <> 0) then
    Error(reRangeError);
  FData := AValue;
end;

class function THalfHelper.Size: Integer;
begin
  Result := SizeOf(Half);
end;

function THalfHelper.SpecialType: TFloatSpecial;
var
  E: Cardinal;
begin
  E := GetExp;
  if (E = $00) then
  begin
    if (FData = $0000) then
      Result := TFloatSpecial.fsZero
    else if (FData = $8000) then
      Result := TFloatSpecial.fsNZero
    else if (FData < $8000) then
      Result := TFloatSpecial.fsDenormal
    else
      Result := TFloatSpecial.fsNDenormal;
  end
  else if (E = $1F) then
  begin
    if (GetFrac = 0) then
    begin
      if (FData < $8000) then
        Result := TFloatSpecial.fsInf
      else
        Result := TFloatSpecial.fsNInf
    end
    else
      Result := TFloatSpecial.fsNaN;
  end
  else
  begin
    if (FData < $8000) then
      Result := TFloatSpecial.fsPositive
    else
      Result := TFloatSpecial.fsNegative
  end;
end;

end.
